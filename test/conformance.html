<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <link rel="stylesheet" href="../lib/jasmine.css" type="text/css" media="screen" />
  <script src="../lib/jasmine.js"></script>
  <script src="../lib/jasmine-html.js"></script>

  <script src="../flowdock-text.js"></script>

  <script src="../test/conformance.js"></script>

  <script>
    function getTester(suite, section) {
      switch (suite) {
        case "autolink":
          switch (section) {
            case "urls":
              return function(test) {
                return FlowdockText.autoLinkUrlsCustom(test.text, {suppressNoFollow: true, suppressDataScreenName: true});
              };
            case "hashtags":
              return function(test) {
                return FlowdockText.autoLinkHashtags(test.text, {suppressNoFollow: true, suppressDataScreenName: true, hashtagUrlBase: "https://twitter.com/#!/search?q=%23"});
              };
            case "usernames":
              return function(test) {
                return FlowdockText.autoLinkMentions(test.text, {suppressNoFollow: true, suppressDataScreenName: true});
              };
            case "lists":
              return function(test) {
                return FlowdockText.autoLinkUsernamesOrLists(test.text, {suppressNoFollow: true, suppressDataScreenName: true});
              };
            case "all":
              return function(test) {
                return FlowdockText.autoLink(test.text, {suppressNoFollow: true, suppressDataScreenName: true});
              };
          }
        case "extract":
          switch (section) {
            case "mentions":
              return function(test) {
                return FlowdockText.extractMentions(test.text);
              };
            case "mentions_with_indices":
              return function(test) {
                var results = FlowdockText.extractMentionsWithIndices(test.text);
                return results.map(function(res) {
                  res['screen_name'] = res.screenName;
                  delete res.screenName
                  return res
                });
              };
            case "mentions_or_lists_with_indices":
              return function(test) {
                var results = FlowdockText.extractMentionsOrListsWithIndices(test.text);
                return results.map(function(res) {
                  res['screen_name'] = res.screenName;
                  res['list_slug'] = res.listSlug;
                  delete res.screenName;
                  delete res.listSlug;
                  return res;
                });
              };
            case "replies":
              return function(test) {
                return FlowdockText.extractReplies(test.text);
              };
            case "urls":
              return function(test) {
                return FlowdockText.extractUrls(test.text);
              };
            case "urls_with_indices":
              return function(test) {
                return FlowdockText.extractUrlsWithIndices(test.text);
              };
            case "hashtags":
              return function(test) {
                return FlowdockText.extractHashtags(test.text);
              };
            case "hashtags_with_indices":
              return function(test) {
                return FlowdockText.extractHashtagsWithIndices(test.text);
              };
          }
        case "hit_highlighting":
          return function(test) {
            return FlowdockText.hitHighlight(test.text, test.hits);
          };
        case "validate":
          switch (section) {
            case "tweets":
              return function(test) {
                return FlowdockText.isValidTweetText(test.text);
              };
            case "usernames":
              return function(test) {
                return FlowdockText.isValidUsername(test.text);
              };
            case "lists":
              return function(test) {
                return FlowdockText.isValidList(test.text);
              };
            case "hashtags":
              return function(test) {
                return FlowdockText.isValidHashtag(test.text);
              };
            case "urls":
              return function(test) {
                return FlowdockText.isValidUrl(test.text);
              };
            case "urls_without_protocol":
              return function(test) {
                return FlowdockText.isValidUrl(test.text, true, false);
              };
          }
      }

    }

    for (var suite in cases) {
      (function(suite) {
        describe(suite, function(){
          for (var section in cases[suite]) {
            (function(section) {
              describe(section, function() {
                cases[suite][section].forEach(function(testCase){
                  var tester = getTester(suite, section);
                  it(testCase.description, function(){
                    expect(tester(testCase)).toEqual(testCase.expected);
                  });
                });
              });
            }(section));
          }
        });

      }(suite));
    }

  </script>

</head>
<body>
</body>
<script type="text/javascript">
  jasmine.getEnv().addReporter(new jasmine.TrivialReporter());
  jasmine.getEnv().execute();
</script>
</html>
